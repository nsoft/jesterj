//file:noinspection VulnerableLibrariesLocal
import org.jesterj.licensereport.PreferredLicensesFilter

import java.text.SimpleDateFormat
import java.time.Instant

/*
 * Copyright 2013-2018 Needham Software LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    //Check for the latest version here: http://plugins.gradle.org/plugin/com.jfrog.artifactory
    classpath "org.jfrog.buildinfo:build-info-extractor-gradle:4+"
  }
}

plugins {
  id 'java-library'
  id 'idea'
  id 'jacoco'
  id 'signing'
//  id 'maven'
  id 'maven-publish'
  id 'com.palantir.git-version'
  id 'com.github.jk1.dependency-license-report' version '2.1'  // fersion determined in buildSrc
  id "com.github.onslip.gradle-one-jar" version "1.0.5"
  id 'com.needhamsoftware.unojar' version '1.1.0'
}




idea {
  module {
    downloadJavadoc = true
    downloadSources = true
  }
}

repositories {
  mavenLocal()
  mavenCentral()
}

configurations {
  unoJarPack
  // under no circumstances shall we distribute these in our archives
  unoJarPack.exclude group: 'junit'               // test lib
  unoJarPack.exclude group: 'org.easymock'        // test lib
  // Conflicting licenses...
  unoJarPack.exclude group: 'org.jboss.logging'
  unoJarPack.exclude group: 'com.github.spotbugs'
  unoJarPack.exclude group: 'com.google.code.findbugs', module: 'annotations' // N.B. findbugs jsr305 is ok, thus module
  unoJarPack.exclude group: 'c3p0', module: 'c3p0'
  unoJarPack.extendsFrom implementation
}

configurations.all {
  resolutionStrategy.cacheDynamicVersionsFor 1, 'minutes'
  resolutionStrategy.cacheChangingModulesFor 1, 'minutes'
}

//////////////////////////

version = '1.0.0'
group = 'org.jesterj'
ext.shortDesc = 'JesterJ Core API'
description = 'Library for writing JesterJ ingestion plans'

ext.archiveName = 'jesterj-ingest'

//////////////////////////


dependencies {
  implementation 'com.needhamsoftware.unojar:core:1.0.2'
  implementation 'io.github.classgraph:classgraph:4.8.147'
  api 'org.apache.tika:tika-core:2.4.1'
  implementation 'org.apache.tika:tika-parsers-standard-package:2.4.1'

  api 'org.apache.solr:solr-core:9.1.0'

  // until SOLR 9.1.1 (should be safe see https://issues.apache.org/jira/browse/SOLR-16568)
  api 'com.fasterxml.woodstox:woodstox-core:6.4.0'

  implementation 'com.google.guava:guava:31.1-jre'
  implementation 'com.google.code.findbugs:jsr305:3.0.2'

  // IDE checker reports CVE-2021-21290, CVE-2021-21295, CVE-2021-37137, CVE-2021-43797 in transitive deps.
  // The Cassandra devs have determined that these are not relevant to usage of cassandra
  // https://github.com/apache/cassandra/blob/c378874a9fa123891d1d75177d99dba5c4d18f9b/.build/dependency-check-suppressions.xml
  // Note: there are (as of now) no netty import statements, so we're not using any vulnerable code either.
  //noinspection VulnerableLibrariesLocal
  implementation ('org.apache.cassandra:cassandra-all:4.1.0') {
    exclude group:'ch.qos.logback'
  }

  // until https://issues.apache.org/jira/browse/CASSANDRA-17966 easy and likely safe way to make CVE-2022-42004 go away
  api 'com.fasterxml.jackson.core:jackson-core:2.13.4'
  api 'com.fasterxml.jackson.core:jackson-databind:2.13.4.2'

  // CVE-2021-24823 --> waiting for 4.15 to release.
  //noinspection VulnerableLibrariesLocal
  implementation 'com.datastax.oss:java-driver-core:4.14.1'
  implementation 'org.yaml:snakeyaml:1.33'
  api 'org.apache.velocity:velocity-engine-core:2.3'

  api 'org.apache.logging.log4j:log4j-core:2.17.2'
  implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.17.2'
  implementation 'org.apache.logging.log4j:log4j-jcl:2.17.2'
  implementation 'org.apache.logging.log4j:log4j-1.2-api:2.17.2'
  implementation 'org.apache.logging.log4j:log4j-jul:2.17.2'

  implementation('com.needhamsoftware:easier-mock:2.0') {
    exclude group:'org.easymock'
    exclude group:'junit'
  }
  implementation('org.objenesis:objenesis:3.2')
  implementation 'com.offbytwo:docopt:0.6.0.20150202'
  implementation 'guru.nidi:graphviz-java:0.18.1'
  implementation 'com.fasterxml:aalto-xml:1.3.2'
  implementation 'xml-resolver:xml-resolver:1.2'
  testImplementation 'junit:junit:4.13.2'
  testImplementation 'org.easymock:easymock:4.3'
  testImplementation 'org.hsqldb:hsqldb:2.6.1'
  testImplementation ('com.needhamsoftware:easier-mock:2.0') {
    exclude group:'org.easymock'
    exclude group:'junit'
  }
  testImplementation 'com.opencsv:opencsv:4.1'

  // this shouldn't be necessary but there's something dodgy going on with jacocoTestReport's classpath
  // using testImplementation so we don't package these...
  testImplementation (group: 'org.jacoco', name:'org.jacoco.report', version:'0.7.7.201606060606')
  testImplementation (group: 'org.jacoco', name:'org.jacoco.core', version:'0.7.7.201606060606')
  testImplementation 'org.apache.solr:solr-test-framework:9.1.0'
}

import com.github.jk1.license.filter.*
import com.github.jk1.license.render.*
licenseReport {
//  unionParentPomLicenses = false
  configurations = ['unoJarPack']
  renderers = [new InventoryHtmlReportRenderer(), new JsonReportRenderer("index.json", false)]
  allowedLicensesFile = new File("$projectDir/licenses/allowed-licenses.json")

  def normalizer = new LicenseBundleNormalizer(
      bundlePath: "$projectDir/licenses/license-normalizer-bundle.json",
      createDefaultTransformationRules: false)

//  def preferences = new PreferredLicensesFilter([
//      "Apache-2.0",
//      "Apache-1.0-no-acknowledge",
//      "CC0-1.0",
//      "MIT",
//      "MIT-OneJar",
//      "BSD-2-Clause",
//      "BSD-3-Clause",
//      "BSD-3-Clause-Nuclear",
//      "Eclipse-Distribution-1.0",
//      "Bouncy-Castle",
//      "CUP-Parser",
//      "ISC",
//      "Public-Domain",
//      "Eclipse-Public-1.0",
//      "Eclipse-Public-2.0",
//      "Mozilla-1.1",
//      "CDDL-1.0",
//      "UnRar"
//  ])
  filters = [normalizer]//, preferences]
}
import groovy.json.JsonSlurper

import java.util.concurrent.atomic.AtomicInteger

tasks.register("verifyLicenseDirs") {
  // This task ensures that if we add a library and update the permitted licenses to add a new license type
  // we don't forget to add a directory for it under /licenses
  doLast {

    // This requires a not-yet-released bugfix for gradle-license-report
    // (see https://github.com/jk1/Gradle-License-Report/issues/264)

//    def jsonReport = new File("$projectDir/build/reports/dependency-license/index.json").text
//    def jsonSlurper = new JsonSlurper()
//    def obj = jsonSlurper.parseText(jsonReport)
//    def numberOfDependencies = obj["dependencies"].size()
//    println "Found " + numberOfDependencies + " dependencies"
//    def licenseTypes = new HashSet()
//    def licenseDirs = new HashSet()
//    obj["dependencies"].each {
//      def licenses = it["moduleLicenses"]
//      def modLic = licenses?[0]?["moduleLicense"]
//      if (modLic == null) {
//        // check special cases manually here so a new module with no licenses doesn't cause issues.
//        // see https://github.com/jk1/Gradle-License-Report/issues/263
//        if ("com.fasterxml.jackson:jackson-bom".equals(it["moduleName"]) && "2.13.4".equals(it["moduleVersion"])) {
//          licenseTypes.add("Apache-2.0")
//        } else {
//          ant.fail("New, unknown (null) license for dependency:" + it)
//        }
//      } else {
//        licenseTypes.add(modLic)
//      }
//    }
//    //println licenseTypes
//    def licDir = new File("$projectDir/licenses")
//    licDir.eachDir {
//      licenseDirs.add(it.getName())
//    }
//    //println licenseDirs
//    def fail = false
//    def possibleDisallowed = new HashSet()
//    licenseTypes.each {
//      if (licenseDirs.contains(it)) {
//        //println it + " OK (License Dir found)"
//      } else {
//        possibleDisallowed.add(it)
//      }
//    }
//    // The dependencyCheck target is used to flag libraries that ONLY have a disallowed license, so
//    // now we need to verify that none of the licenses that remain are listed as permitted since
//    // that would indicate a gap in our documentation (we don't have to document disallowed licenses we haven't
//    // elected to use)
//    def allowedLicFile = new File("$projectDir/licenses/allowed-licenses.json").text
//    def allowedLic = jsonSlurper.parseText(allowedLicFile)
//
//    def allowedNames = allowedLic["allowedLicenses"].collect() {
//      return it["moduleLicense"]
//    }
//    possibleDisallowed.each {
//      if (allowedNames.contains(it)) {
//        fail = true
//        println "FAIL:" + it + " (No directory, but listed as allowed)"
//      }
//    }
//    if(fail) {
//      ant.fail("One or more permitted license types do not have a directory in licenses (or are not recognized by the normalizer)")
//    }
//    def missingCount = 0
//    obj["dependencies"].each {
//      def licenses = it["moduleLicenses"]
//      def modLic = licenses?[0]?["moduleLicense"]
//      if(possibleDisallowed.contains(modLic)) {
//        return
//      }
//
//      if (!modLic) {
//        if ("com.fasterxml.jackson:jackson-bom".equals(it["moduleName"]) && "2.13.4".equals(it["moduleVersion"])) {
//          modLic = "Apache-2.0"
//        } else {
//          ant.fail("New, unknown (null) license for dependency:" + it)
//        }
//      }
//
//      def readme1 = "$projectDir/licenses/" + modLic + "/README.txt"
//      def license = "$projectDir/licenses/" + modLic + "/" + modLic + ".txt"
//      def artifact = it["moduleName"].contains(":") ? it["moduleName"].split(":")[1] : it["moduleName"]
//      def version = it["moduleVersion"]
//      def readme2 = "$projectDir/licenses/" + modLic + "/" + artifact + "-" + version + "/README.txt"
//      def notice = "$projectDir/licenses/" + modLic + "/" + artifact + "-" + version + "/NOTICE.txt"
//      def notice_md = "$projectDir/licenses/" + modLic + "/" + artifact + "-" + version + "/NOTICE.md"
//
//      def readmeFile1 = file(readme1)
//      if (!readmeFile1.exists()) {
//        fail = true
//        missingCount++
//        println "FAIL: license level README.txt not found at " + readme1
//      }
//
//      def licenseFile = file(license)
//      if (!licenseFile.exists()) {
//        if ("Public-Domain" == modLic) {
//          def pubDomLic = license.replace("Public-Domain.txt", "Apache-JJ-2.0.txt" )
//          def pubDomLicFile = file(pubDomLic)
//          if (!pubDomLicFile.exists()) {
//            fail = true
//            missingCount++
//            println "FAIL: special license file for public domain not found at " + pubDomLic
//          }
//        } else {
//          fail = true
//          missingCount++
//          println "FAIL: license file not found at " + license
//        }
//      }
//
//      def readmeFile2 = file(readme2)
//      if (!readmeFile2.exists()) {
//        fail = true
//        missingCount++
//        println "FAIL: library level README.txt not found at " + readme2
//      }
//
//      def noticeFile = file(notice)
//      def noticeMdFile = file(notice_md)
//      if ("Apache-2.0" == modLic) {
//        if (!noticeFile.exists() && !noticeMdFile.exists()) {
//          fail = true
//          missingCount++
//          println "FAIL: library level NOTICE.txt not found at " + notice
//        }
//      }
//    }
//
//    if(fail) {
//      ant.fail(missingCount + " license documentation errors were found. See above output for details")
//    }
//
//    def licsByDep = [:]
//    for (Object dir : licenseDirs) {
//      def ld = new File("$projectDir/licenses/$dir")
//      ld.eachDir {
//        def deps = licsByDep.get(it.name, [])
//        deps.add(ld.name)
//        if (deps.size() > 1) {
//          fail = true;
//          println "FAIL: " + it.name + " exists in multiple license directories: " + deps
//        }
//      }
//    }
//
//    if(fail) {
//      ant.fail("Some dependencies have been listed in more than one license dir see output above for details")
//    }
//
  }
}

tasks.register("validateLicenseLinks") {
  def licDir = new File("$projectDir/licenses")
  def count = new AtomicInteger(0)
  def manualChecks = []
  licDir.eachDir {
    it.listFiles().each {
      checkFileUrls(it, count, manualChecks)
    }
  }
  println "Processed " + count.get() + " links"
  println "The following links prevent automated verification, please check them manually"
  manualChecks.each {
    println it
  }

}

private void checkFileUrls(File f, AtomicInteger count, List manualChecks) {
  if (f.isDirectory()) {
    f.listFiles().each {
      checkFileUrls(it, count, manualChecks)
    }
  } else {
    if (f.getName().contains("README")) {
      f.readLines().each {
        def match = (it =~ /^\s*(https?:\/\/[^,<>)\s]+[^.,<>)\s]).*/)
        if (match.find()) {
          def url = match.group(1)
          checkLink(url,f, manualChecks)
          count.incrementAndGet()
        }
      }
    }
  }
}

void checkLink(String s, File f, List manualChecks) {
  sleep(1000)

  def url = new URL(s)
  def get = url.openConnection()
  get.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/112.0")
  get.setRequestProperty("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
  get.setRequestProperty("Accept-Encoding", "gzip, deflate, br")
  get.setRequestProperty("Accept-Language", "en-US,en;q=0.5")
  get.setRequestProperty("Host",url.getHost())
  def respCode = get.getResponseCode()
  def status = "Got response of " + respCode + " from " + s + " in " + f
  if (respCode.equals(403)) {
    // mvnrepository for example sends 403 to us even when browser is fine.
    manualChecks.add(s)
  } else if (!respCode.equals(200)) {
    println get.headerFields
    println get.getContent()
    ant.fail(status)
  } else {
    println status
  }
}

verifyLicenseDirs.dependsOn generateLicenseReport

compileJava {
  options.compilerArgs += ["--add-exports=java.base/jdk.internal.loader=ALL-UNNAMED"]
}

javadoc {
  options.optionFiles << file('javadoc.options')
}

// these are just support classes for the Trie Tests swiped from commons/collections
// they don't actually have test methods which causes Junit to complain. Just don't run them.
test {
  maxHeapSize = "4g"
  //maxParallelForks = 6
  exclude '**/Abstract*.class', '**/BulkTest.class'
  forkEvery 1 // temp until we can get FTI tests moved into a separate target.
  systemProperty "java.security.egd", "file:/dev/./urandom"
  systemProperty "jj.log.dir", "build"
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat "full"
  }

  doFirst {
    jvmArgs += [
        '-Djesterj.build.start=' + String.valueOf(Instant.now().toEpochMilli()),
        '--add-modules', 'ALL-MODULE-PATH',
        '--add-opens', 'java.base/java.lang.module=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.loader=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.ref=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.reflect=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.math=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.module=ALL-UNNAMED',
        '--add-opens', 'java.base/jdk.internal.util.jar=ALL-UNNAMED',
        '--add-opens', 'jdk.management/com.sun.management.internal=ALL-UNNAMED'
    ]
  }
}

tasks.register('quickTest', Test) {
  maxHeapSize = "4g"
  //maxParallelForks = 6
  exclude '**/Abstract*.class', '**/BulkTest.class', 'org/jesterj/ingest/indexing/**'
  forkEvery 1 // temp until we can get FTI tests moved into a separate target.
  systemProperty "java.security.egd", "file:/dev/./urandom"
  systemProperty "jj.log.dir", "build"
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat "full"
  }

  jvmArgs += [
      '-Djesterj.build.start=' + String.valueOf(Instant.now().toEpochMilli()),
      '--add-modules', 'ALL-MODULE-PATH',
      '--add-opens', 'java.base/java.lang.module=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.loader=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.ref=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.reflect=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.math=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.module=ALL-UNNAMED',
      '--add-opens', 'java.base/jdk.internal.util.jar=ALL-UNNAMED',
      '--add-opens', 'jdk.management/com.sun.management.internal=ALL-UNNAMED'
  ]
}

quickTest.group = 'verification'
quickTest.description = 'Run all tests except the FTI tests and other full integration tests that have long delays'

jacocoTestReport {
  reports {
    xml.enabled true
  }
}

jar {
  archiveFileName = archiveName +'-'+project.version+'.jar'
  into("META-INF/maven/$project.group/$project.name") {
    from { generatePomFileForMavenJavaPublication }
    rename ".*", "pom.xml"
  }
  into("META-INF") {
    from "$projectDir/NOTICE.txt"
  }
  into("META-INF") {
    from "$projectDir/LICENSE.txt"
  }
}



unojar {
  archivesBaseName = archiveName
  archiveClassifier = "node"
  mainClass = 'org.jesterj.ingest.Main'
  manifestAttributes = [
      // exports/opens for cassandra
      'Add-Exports': 'java.base/jdk.internal.misc java.base/jdk.internal.ref java.base/sun.nio.ch' +
          ' java.management.rmi/com.sun.jmx.remote.internal.rmi java.rmi/sun.rmi.registry' +
          ' java.rmi/sun.rmi.server java.sql/java.sql',
      // this is not part of the jar standard, but I expect to support it in UnoJar
      'Add-Opens' : 'java.base/java.lang.module java.base/jdk.internal.loader java.base/jdk.internal.ref' +
          ' java.base/jdk.internal.reflect java.base/jdk.internal.math java.base/jdk.internal.module ' +
          ' java.base/jdk.internal.util.jar jdk.management/com.sun.management.internal'
  ]
}

def nodeFile = file("$buildDir/libs/" + tasks.getByName("packageUnoJar").getArchiveFileName())
classes.dependsOn checkLicense
classes.dependsOn verifyLicenseDirs
packageUnoJar.dependsOn build
packageUnoJar.doLast {
  def licDir = file('licenses').parent

  ant.jar(update: true, destFile: nodeFile) {
      fileset(dir: licDir) {
        include(name: 'licenses/**')
        include(name: 'NOTICE.txt')
        include(name: 'LICENSE.txt')
      }
    }
  }

tasks.register('generateNotices') {
  doLast {
    def toConcatenate = fileTree(file('licenses')) {
      include '**/NOTICE.txt'
      include '**/NOTICE.md'
    }
    def header = new File("notice-header.txt")
    def output = new File("NOTICE.txt")
    output.write('') // truncate file
    output << header.text
    toConcatenate.each { f ->
      output << "\n\n-------------------------------------------------------------------------------\n"
      output << "       NOTICE for " + (file(f.parent).name)
      output << "\n-------------------------------------------------------------------------------\n"

      output << f.text
    }
  }
}
packageUnoJar.dependsOn generateNotices
jar.dependsOn generateNotices



jacocoTestReport.dependsOn test

tasks.register('sourcesJar', Jar) {
  dependsOn classes
  //noinspection GroovyAccessibility
  archiveClassifier = 'sources'
  from sourceSets.main.allSource
  archiveFileName = 'jesterj-ingest-' + project.version + '-sources.jar'
  into("META-INF") {
    from "$projectDir/NOTICE.txt"
  }
  into("META-INF") {
    from "$projectDir/LICENSE.txt"
  }
}

tasks.register('javadocJar', Jar) {
  dependsOn javadoc
  //noinspection GroovyAccessibility
  archiveClassifier = 'javadoc'
  from javadoc.destinationDir
  archiveFileName = 'jesterj-ingest-' + project.version + '-javadoc.jar'
  into("META-INF") {
    from "$projectDir/NOTICE.txt"
  }
  into("META-INF") {
    from "$projectDir/LICENSE.txt"
  }
}

artifacts {
  archives sourcesJar
  archives javadocJar
}

// A little idiot proofing...
tasks.register('checkUploadDest') {
  doLast {
    if (gradle.taskGraph.hasTask(':uploadRelease')) {
      if (isSnapshot) {
        ant.fail('Release should not have suffix of -SNAPSHOT')
      }
      if (isLocal) {
        ant.fail('Release should not have suffix of -LOCAL')
      }
    } else if (gradle.taskGraph.hasTask(':uploadSnapshot')) {
      if (!isSnapshot) {
        ant.fail('Snapshot should have suffix of SNAPSHOT')
      }
    } else {
      if (!isLocal) {
        ant.fail('This is not a local version, ' +
            'please use either uploadRelease or uploadSnapshot, or change the version suffix to -LOCAL')
      }
    }
  }
}

// fix grouping of tasks in ide
checkLicense.group = "license"
checkLicensePreparation.group = "license"
verifyLicenseDirs.group = "license"
generateNotices.group = "license"
generateLicenseReport.group = "license"

javadoc {
  if(JavaVersion.current().isJava9Compatible()) {
    options.addBooleanOption('html5', true)
  }
}

jar.manifest.attributes getManifestAttributes()
sourcesJar.manifest.attributes getManifestAttributes()
javadocJar.manifest.attributes getManifestAttributes()

@SuppressWarnings("GroovyAssignabilityCheck")
def getManifestAttributes() {
  def gitDetails = versionDetails()
  Map<String, String> attrs = new LinkedHashMap<>()
  attrs.put('Implementation-Title', project.name)
  attrs.put('Implementation-Version', version)
  attrs.put('Build-Revision', gitDetails.gitHashFull + (gitDetails.clean ? '' : ' (with uncommitted files)'))
  attrs.put('Created-By', "Gradle ${gradle.gradleVersion}")
  attrs.put('Build-Jdk', getJdk())
  attrs.put('Build-OS', "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}")
  return attrs
}

static def getJdk() {
  "${System.getProperty('java.version')} (${System.getProperty('java.vm.vendor')} ${System.getProperty('java.vm.version')})"
}

apply from:  file('./gradle/publishing/publishing.gradle')

generateMetadataFileForMavenJavaPublication.dependsOn(packageUnoJar)